package main

import (
	"errors"
	"fmt"
	"os"
	"strings"

	"github.com/pb33f/libopenapi"
	"github.com/pb33f/libopenapi/datamodel/high/base"
	v3 "github.com/pb33f/libopenapi/datamodel/high/v3"
)

func GenerateModels(spec *libopenapi.DocumentModel[v3.Document], packagePath, outputPath string) error {
	g := &Generator{}

	// Get the package name and generate file header.
	packageName, err := LoadPackageName(packagePath)
	if err != nil {
		return err
	}

	g.Printf(`package %s

// Code generated by "fiberopenapi %s"; DO NOT EDIT.

type Nullable[T any] struct {
	Value  T
	isNull bool
}

func (n *Nullable[T]) IsNull() bool {
	return n.isNull
}

type Optional[T any] struct {
	Value *T
}

func (o *Optional[T]) IsUndefined() bool {
	return o.Value == nil
}
`,
		packageName,
		strings.Join(os.Args[1:], " "),
	)

	// Generate schema models.
	for pair := spec.Model.Components.Schemas.First(); pair != nil; pair = pair.Next() {
		name := pair.Key()
		schema := pair.Value().Schema()
		GenerateModel(g, name, schema)
	}

	// Write the generated code.
	if err := g.WriteFile(outputPath); err != nil {
		return fmt.Errorf("cannot write generated code: %w", err)
	}
	return nil
}

func GenerateModel(g *Generator, name string, schema *base.Schema) (err error) {
	// TODO(GIA) Handle multiple types.

	switch schema.Type[0] {
	case "object":
		g.Printf("type %s struct {\n", name)
		for pair := schema.Properties.First(); pair != nil; pair = pair.Next() {
			propertyName := pair.Key()
			propertyProxy := pair.Value()
			property := propertyProxy.Schema()
			g.Printf("\t%s %s `json:\"%s\"`\n", ToPascalCase(propertyName), property.Type, propertyName)
			if !propertyProxy.IsReference() {
				defer func() {
					err = errors.Join(err,
						GenerateModel(g, ToPascalCase(propertyName), property),
					)
				}()
			}
		}
		g.Printf("}\n\n")
	case "string":
		g.Printf("type %s string\n\n", ToPascalCase(name))
	default:
		return fmt.Errorf("unsupported type: %s", schema.Type[0])
	}
	return nil
}
