package main

import (
	"fmt"
	"os"
	"strings"

	"github.com/pb33f/libopenapi"
	v3 "github.com/pb33f/libopenapi/datamodel/high/v3"
)

func GenerateHandlers(spec *libopenapi.DocumentModel[v3.Document], packagePath, outputPath, typeName string) error {
	g := &Generator{}

	// Get the package name and generate file header.
	packageName, err := LoadPackageName(packagePath)
	if err != nil {
		return err
	}
	g.Printf(`package %s

// Code generated by "fiberopenapi %s"; DO NOT EDIT.

import (
	"encoding/json"

	"github.com/gofiber/fiber/v2"
)
`,
		packageName,
		strings.Join(os.Args[1:], " "),
	)

	operations := ExtractOperations(spec)

	// Generate the ValidatedHandlers interface.
	g.Printf(`
// Implement this interface.
type %s interface {
`,
		typeName,
	)
	for _, operation := range operations {
		g.Printf("\t%s(c *fiber.Ctx", operation.Name)
		if operation.RequestBody != "" {
			g.Printf(", body %s", operation.RequestBody)
		}
		for _, parameter := range operation.Parameters {
			g.Printf(", %s %s", parameter.Name, parameter.Type)
		}
		// TODO response types
		g.Println(") error")
	}
	g.Println("}")

	// Generate the raw rawHandlers interface.
	g.Println("\ntype rawHandlers interface {")
	for _, operation := range operations {
		g.Printf("\t%s(c *fiber.Ctx) error\n", ToPascalCase(operation.Name))
	}
	g.Println("}")

	// Generate AddHandlers function.
	g.Println("\nfunc addRawHandlers(app *fiber.App, h rawHandlers) {")
	for _, operation := range operations {
		g.Printf("\tapp.%s(\"%s\", h.%s)\n",
			operation.Method, operation.Path, operation.Name,
		)
	}
	g.Println("}")

	// Generate the wrapper that implements the raw handlers interface.
	g.Printf(`
type validated%s struct {
	validated %s
}

func Add%s(app *fiber.App, h %s) {
	addRawHandlers(app, &validated%s{h})
}`+"\n",
		typeName, typeName, typeName, typeName, typeName,
	)
	for _, operation := range operations {
		g.Printf("\nfunc (h *validated%s) %s(c *fiber.Ctx) error {",
			typeName, operation.Name,
		)
		if operation.RequestBody != "" {
			// The request body type implements json.Unmarshaler and will be
			// validated when unmarshalled.
			g.Printf(`
	var body %s
	if err := json.Unmarshal(c.Body(), &body); err != nil {
		return err
	}`,
				operation.RequestBody,
			)
		}
		for _, parameter := range operation.Parameters {
			// The parameter type implements json.Unmarshaler and will be
			// validated when unmarshalled.
			g.Printf(`
	var %s %s
	if err := json.Unmarshal([]byte(c.Params("%s")), &%s); err != nil {
		return err
	}`,
				parameter.Name, parameter.Type, parameter.Name, parameter.Name,
			)
		}
		g.Printf("\n\treturn h.validated.%s(c", operation.Name)
		if operation.RequestBody != "" {
			g.Printf(", body")
		}
		for _, parameter := range operation.Parameters {
			g.Printf(", %s", parameter.Name)
		}
		g.Println(")\n}")
	}
	// Write the generated code back to main.go
	if err := g.WriteFile(outputPath); err != nil {
		return fmt.Errorf("cannot write generated code: %w", err)
	}
	return nil
}
