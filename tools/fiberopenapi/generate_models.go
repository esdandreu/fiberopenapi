package main

import (
	_ "embed"
	"errors"
	"fmt"
	"os"
	"strings"

	"github.com/pb33f/libopenapi"
	"github.com/pb33f/libopenapi/datamodel/high/base"
	v3 "github.com/pb33f/libopenapi/datamodel/high/v3"
)

//go:embed models.go
var modelsFile string

func GenerateModels(spec *libopenapi.DocumentModel[v3.Document], packagePath, outputPath string) error {
	g := &Generator{}

	// Get the package name and generate file header.
	packageName, err := LoadPackageName(packagePath)
	if err != nil {
		return err
	}

	g.Printf(`package %s

// Code generated by "fiberopenapi %s"; DO NOT EDIT.

%s
`,
		packageName,
		strings.Join(os.Args[1:], " "),
		strings.TrimPrefix(modelsFile, "package main\n\n"),
	)

	// Generate schema models.
	err = generateModels(g, spec)
	if err != nil {
		return err
	}

	// Write the generated code.
	if err := g.WriteFile(outputPath); err != nil {
		return fmt.Errorf("cannot write generated code: %w", err)
	}
	return nil
}

func generateModels(g *Generator, spec *libopenapi.DocumentModel[v3.Document]) error {
	var errs []error
	for pair := spec.Model.Components.Schemas.First(); pair != nil; pair = pair.Next() {
		name := pair.Key()
		schema := pair.Value().Schema()
		err := generateModel(g, name, schema)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return errors.Join(errs...)
}

func modelNameAndType(schemaName string, schema *base.Schema) (string, string) {
	modelName := ToPascalCase(schemaName)
	modelType := modelName
	if schema.Nullable != nil && *schema.Nullable {
		modelType = "Nullable[" + modelType + "]"
	}
	return modelName, modelType
}

func generateModel(g *Generator, schemaName string, schema *base.Schema) (err error) {
	modelName, modelType := modelNameAndType(schemaName, schema)
	// Data types in the OAS are based on the types defined by the JSON Schema
	// Validation Specification Draft 2020-12: "null", "boolean", "object",
	// "array", "number", "string", or "integer".
	schemaType := schema.Type[0]
	generateModelDoc(g, schema)
	switch schemaType {
	case "null":
		return fmt.Errorf("null type not supported")
	case "boolean":
		g.Printf("type %s bool\n", modelType)
	case "object":
		g.Printf("type %s struct {\n", modelType)
		// TODO(GIA) Validation
		for pair := schema.Properties.First(); pair != nil; pair = pair.Next() {
			schemaName := pair.Key()
			modelName, modelType := modelNameAndType(schemaName, schema)
			proxy := pair.Value()
			g.Printf("\t%s %s `json:\"%s\"`\n", modelName, modelType, schemaName)
			if !proxy.IsReference() {
				defer func(schema *base.Schema) {
					err = errors.Join(err,
						generateModel(g, schemaName, schema),
					)
				}(proxy.Schema())
			}
		}
		g.Printf("}\n\n")
	case "array":
		if schema.Items == nil {
			return fmt.Errorf("array type must have an items property")
		}
		if schema.Items.IsB() {
			return fmt.Errorf("array type with boolean items is not supported")
		}
		proxy := schema.Items.A
		if proxy.IsReference() {
			itemName := ToPascalCase(strings.TrimPrefix(
				proxy.GetReference(), "#/components/schemas/",
			))
			g.Printf("type %s []%s\n", modelName, itemName)
		} else {
			itemName := modelName + "Item"
			g.Printf("type %s []%s\n", modelName, itemName)
			defer func(schema *base.Schema) {
				err = errors.Join(err,
					generateModel(g, itemName, schema),
				)
			}(proxy.Schema())
		}
		// TODO(GIA) Check schema.Items
	case "number", "integer":
		var goType string
		switch schema.Format {
		case "int64":
			goType = "int64"
		case "int32":
			goType = "int32"
		case "float":
			goType = "float32"
		case "double":
			goType = "float64"
		default:
			switch schemaType {
			case "number":
				goType = "float"
			case "integer":
				goType = "int"
			}
		}
		g.Printf("type %s %s\n", modelType, goType)
		// TODO(GIA) Validation
	case "string":
		g.Printf("type %s string\n", modelType)
		gv := &Generator{}
		if schema.MaxLength != nil {
			want := *schema.MaxLength
			gv.Printf("\tif got := len(v); got > %d {\n", want)
			gv.Printf("\t\terrs = append(errs, NewMaxLengthError(got, %d))\n", want)
			gv.Println("\t}")
		}
		// ? schema.MinLength
		// ? schema.Pattern or schema.Format
		if !gv.IsEmpty() {
			g.Printf("\nfunc (v %s) Validate() error {\n", modelType)
			g.Println("\tvar errs []error")
			g.MergeIn(gv)
			g.Printf("\treturn errors.Join(errs...)\n}\n")
		}
	default:
		return fmt.Errorf("unsupported type: %s", schemaType)
	}
	return nil
}

func generateModelDoc(g *Generator, schema *base.Schema) {
	g.Println()
	if schema.Deprecated != nil && *schema.Deprecated {
		if schema.Description != "" {
			g.Printf("// Deprecated: %s\n", schema.Description)
		} else {
			g.Println("// Deprecated")
		}
	} else if schema.Description != "" {
		g.Printf("// %s\n", schema.Description)
	}
	// ? schema.ExternalDocs
	// ? schema.Example
	// ? schema.Examples
}
